include "utils/executor.bzz"
include "utils/types.bzz"
include "vec2.bzz"

###############################
### leader
###############################
leader = nil

MAX_LOS_ANGLE = 50.0
MIN_LEADER_DISTANCE = 1.0
NO_BEHAVIOR = 1
FOLLOW_LEADER_BEHAVIOR = 2
HEXAGON_BEHAVIOR = 3


function follow_leader(stig){
    if(leader != id and leader != nil){
        log("Trying to get leader: ", leader)
        var leader_obj = neighbors.get(leader) # Global to be accessible in filter
        if (istable(leader_obj)){
            if(leader_obj.distance > 0.75){ # Final distance from leader to stop
                # Getting neighbors in LOS
                var obstructing_neighbors = neighbors.filter(function(rid, data){
                        if(rid != leader and data.distance < 1){ 
                            return true
                        }
                        return false
                    })

                # Cummulating the avoidance vector
                var avoidance_vec = obstructing_neighbors.reduce(function(rid, data, accum){
                        var vec_length = -0.75/data.distance
                        var vec = math.vec2.newp(vec_length, data.azimuth)
                        return math.vec2.add(vec, accum);
                    },
                    math.vec2.new(0.0, 0.0))

                # Goal to the leader and add the avoidance vector
                var goal = math.vec2.newp(leader_obj.distance, leader_obj.azimuth)

                if(math.vec2.length(goal) > 1){
                    goal = math.vec2.norm(goal)
                }

                goal = math.vec2.add(goal, avoidance_vec)
                goal = math.vec2.norm(goal)

                log("Avoidance vector: X ", avoidance_vec.x, " Y: ", avoidance_vec.y)
                log("Moving towards leader via: ", leader, " at x:", goal.x, " y:", goal.y)
                call_host_function(id, "moveBy", {.0 = goal.x, .1 = goal.y})
            }
            else {
                call_host_function(id, "moveBy", {.0 = 0.0, .1 = 0.0})
            }
        }
        else{
            log("Neighbor not found!")
        }
    }
}

function tick_update_leader(stig){
    leader = stig.get("leader")
    var behavior = stig.get("behavior")
    if (leader and behavior == FOLLOW_LEADER_BEHAVIOR){
        ui.set_hex(leader)
        log("leader set to: ", leader)
    }
}

###############################
### hexagon
###############################

TARGET = 2.50
EPSILON = 1.500

# Lennard-Jones interaction magnitude
function lj_magnitude(dist, target, epsilon) {
    var td_ratio = target/dist;
    var ratio = -(epsilon / dist) * (math.pow(td_ratio, 4) - math.pow(td_ratio, 2))
    if(ratio > 0){ # If too far, return 1/ratio. So the farther they are, the higher the force will be
        return 0.1/ratio # so the pull force doesn't overwhelmed the push and avoid oscillations #0.01 working not best
    }
    return ratio # If too close, return ratio
}

# Accumulator function
function lj_vector_accum(rid, vec, accum) {
    return math.vec2.add(vec, accum);
}

# Neighbor data to LJ interaction vecor
function lj_vector(rid, data) {
    return math.vec2.newp(lj_magnitude(data.distance, TARGET, EPSILON), data.azimuth)
}

function goto(x, y) {
    call_host_function(id, "moveBy", {.0 = x, .1 = y});
}

# Calculates and actuates the flocking interaction
function hexagon() {

    # Calculate the vector
    var accum = neighbors.map(lj_vector).reduce(lj_vector_accum, math.vec2.new(0.0, 0.0))

    # Scaling vector
    if (neighbors.count() > 0) {
        math.vec2.scale(accum, 1.0 / neighbors.count())
    }

    # Prevents going out of the world in simulation
    if(math.vec2.length(accum) > 5){
        accum = math.vec2.norm(accum);
    }

    # Add a tolerence to prevent perpetual moving
    log("Vector length: ", math.vec2.length(accum));
    if(math.vec2.length(accum) > 0.5){
        log("Moving to X: ", accum.x, " Y: ", accum.y);
        goto(accum.x, accum.y)
    } else {
        log("Stopping");
        goto(0.0, 0.0)
    }
}

###############################
### execution
###############################

function execute_behavior(stig){
    var behavior = stig.get("behavior")
    if(behavior == FOLLOW_LEADER_BEHAVIOR){
        log("Following leader")
        follow_leader(stig)
    }
    else if(behavior == HEXAGON_BEHAVIOR){
        log("Doing hexagon behavior")
        hexagon()
    }
}

function create_exec(delay_ms) {
    var stig = stigmergy.create(1)
    stig.put("behavior", NO_BEHAVIOR)

    # Setting the leader via callback
    var set_leader_id_description = {.0 = {.leader_id=types.INT}}
    var set_leader_id = function(leader_id){
        if (leader_id == 0) {
            self.stig.put("behavior", NO_BEHAVIOR)
            log("Can't set id 0: No behavior mode.")
        }
        else {
            self.stig.put("leader", leader_id)
            self.stig.put("behavior", FOLLOW_LEADER_BEHAVIOR)
            log("Setting leader to: ", leader_id)
        }
    }
    register_closure("setLeader", set_leader_id, set_leader_id_description, {.stig = stig})


    var hexagon_formation_return_description = {.0 = {.is_active=types.INT}}
    var set_hexagon_formation = function(is_active) {
        if (is_active == 1) {
            self.stig.put("behavior", HEXAGON_BEHAVIOR)
            log("Setting formation behavior active.")
        }
        else {
            self.stig.put("behavior", NO_BEHAVIOR)
            log("Setting no behavior.")
        }
    }
    
    register_closure("setFormation", set_hexagon_formation, hexagon_formation_return_description, {.stig = stig})
    

    # Creating exec
    var behavior_exec = executor.new_ms(delay_ms, execute_behavior, stig)
    var update_leader_exec = executor.new_ms(4*delay_ms, tick_update_leader, stig) # Refresh leader slower than following it

    # Merging in a collection
    var exec_collection = executor_collection.new()
    exec_collection.append(behavior_exec)
    exec_collection.append(update_leader_exec)

    return exec_collection
}

