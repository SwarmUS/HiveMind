include "vec2.bzz" # This file is from the buzz "standard library". It's included with the compiler
include "utils/executor.bzz"
include "utils/types.bzz"

# Lennard-Jones parameters
TARGET_KIN     = 283.0
EPSILON_KIN    = 150.0
TARGET_NONKIN  = 200.0
EPSILON_NONKIN = 100.0

# Lennard-Jones interaction magnitude
function lj_magnitude(dist, target, epsilon) {
    dist = dist * 100; # Meters to cm
    var td_ratio = target/dist;
    return -(epsilon / dist) * (math.pow(td_ratio, 4) - math.pow(td_ratio, 2))
}
 
# Neighbor data to LJ interaction vecor
function lj_vecor_kin(rid, data) {
    return math.vec2.newp(lj_magnitude(data.distance, TARGET_KIN, EPSILON_KIN), data.azimuth)
}
 
# Neighbor data to LJ interaction vecor
function lj_vecor_nonkin(rid, data) {
    return math.vec2.newp(lj_magnitude(data.distance, TARGET_NONKIN, EPSILON_NONKIN), data.azimuth)
}
 
# Accumulator of neighbor LJ interactions
function lj_sum(rid, data, accum) {
    return math.vec2.add(data, accum)
}

function goto(x, y) {
    call_host_function(id, "moveBy", {.0 = x, .1 = y});
}

function is_kin(robot_id){
    if((robot_id % 2) == (id % 2)){
        return true;
    }
    return false;
}

# Calculates and actuates the flocking interaction
function square() {
    # Calculate accumulator
    var accum_vec = math.vec2.new(0.0, 0.0);
    for (i = 1, i<5, i = i+1){
        if (i != id) {
            var neighbor_data = neighbors.get(i)
            if(is_table(neighbor_data)){
                if(is_kin(i)){
                    neighbor_vec = lj_vecor_kin(i, neighbor_data);
                }
                else {
                    neighbor_vec = lj_vecor_nonkin(i, neighbor_data);
                }
                accum_vec = math.vec2.add(neighbor_vec, accum_vec)
            }
            else {
                log("neighbor: ", i, " is nil")
            }
        }
    }

    if(math.vec2.length(accum_vec) > 0){
        var ncount = neighbors.count() - 1;
        if(ncount > 0){
            accum_vec = math.vec2.scale(accum_vec, 1.0 / ncount);

            # Move according to vecor
            log("Moving to X: ", accum_vec.x, " Y: ", accum_vec.y);
            goto(accum_vec.x, accum_vec.y)
        }
    }
}

# Executed every time step
function tick(ctx) {
    square();
}

# Executed at init time
function create_exec(step_count) {
    exec = executor.new(step_count, tick, nil);
    return exec;

}
